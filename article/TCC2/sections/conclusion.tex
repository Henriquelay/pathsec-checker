\section{Conclusion and Future Work} \label{sec:conclusion}


The implementation and evaluation of \pathsec demonstrate the feasibility of a path-aware routing mechanism that enhances network security through path verification. By leveraging hash-based authentication computed by stateless core switches, the system ensures that packets adhere to their intended routes, enabling a trusted entity to detect deviations caused by attacks or misconfigurations. The proof-of-concept implementation in Mininet with BMv2 switches programmed in P4 highlights the practicality of deploying such a mechanism in programmable networks. The experimental results confirm the effectiveness of the probing-based approach in identifying various adversarial scenarios, reinforcing its potential as a security measure for source-routing protocols like \polka.  

While the study validates the fundamental principles behind \pathsec, future work could explore optimizations to improve scalability and efficiency in larger network deployments. Further research is needed to evaluate the system’s performance under high traffic loads and its adaptability to dynamic network conditions. Additionally, integrating \pathsec with other security mechanisms could enhance its resilience against more sophisticated attack strategies. Overall, this work provides a first step for advancing path-aware security in programmable networks and highlights the potential of verification-based approaches to strengthen network integrity.



%As the examples show, our solution is able to detect when a packet is not following the expected path for most cases, and can be used to detect misconfigurations in the network.

%As next steps, more parts of \pathsec \cite{pathsec} could be easily integrated for proof-of-concept, as all necessary information is already readily collect to Python scripts, making it simple to create 
%BETA
%a complete \pathsecproof-of-concept software.

%To improve the system for a real-world scenario, the ingress edge needs to relay the ingressed package metadata directly to the controller, and the egress edge will report the final checksum directly to the blockchain. Having it not passing through the controller.

%One type of attack is not detectable by the current solution, as the switch entry port is not included in the verification. Suppose a topology similar to our addition test (\autoref{scenario:addition}): $s_{add}$, as and attacker would receive the packet instead of $s_6$. $s_{add}$ can inspect or modify the packet as it wants, as long as \lhash field and \timestamp fields are untouched. As long as the verification headers are repeated when passing the packet forward to $s_6$, $s_6$'s hash will act upon the exact same inputs.

%Including the entry port in the checksum would also be an appreciable increase in security, since it increases the number of targets an attacker would need to breach at the same time to be able to alter the path. It could be included in the \siphash key, but a design decision is necessary: there are only 7 bits available, and the port number is 9 bits long. A possible solution would be to use the 8 least significant bits of the port number for both entry and exit port, limiting the number of ports checked before collision to 256, but this would be a reasonable trade-off for the increased security. It would mitigate attacks like previously described, where our probe headers are kept, and the remaining packet has changed. For a proof-of-concept, design was kept closer to the original \pathsec description.

%An interesting work can be done to use a rotating key architecture to detect replay attacks. This is a difficult problem to solve, since the key must be rotated and shared in a way that does not break the network, and of course, a malicious actor cannot acquire it. The key must be shared between the nodes in a secure, atomic way to prevent the network to enter an irrecoverable state. 
%\mycomment{Pareço estar me estendendo mto, mas ainda acho um problema interessante e queria anotar isso de alguma coisa. Mas é um problema buscando uma solução. Manter de alguma forma?}

%Using a keyless hash function, or even a keyed one with hardcoded keys on deployment could be studied, as it would remove the need for a seed \timestamp, but it would require to be a cryptographic hash, otherwise the data used to hash (which needs to include at least the \nodeid) could be derived from a switch's output. This would open ways to use a faster cryptographic hash function, such as xxHash's XXH3.

%A timing analysis and stress tests can both be done to check if the incurred overhead is acceptable for the network, but this would require it to be implemented in hardware, not only in Mininet. The overhead needs to be low 
%for it beto represent a viable solution, otherwise the network will drop packets. Some overhead is acceptable since a configurable ratio/schedule of \polka packets are selected to be probe packets.
